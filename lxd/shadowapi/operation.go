// Code generated by shadowapi/generate - DO NOT EDIT!

package shadowapi

import (
	"fmt"
	"time"

	"github.com/canonical/lxd/shared/api"
)

// Operation is generated from api.Operation - DO NOT EDIT!
type Operation struct {
	ID          string              `json:"id" yaml:"id"`
	Class       string              `json:"class" yaml:"class"`
	Description string              `json:"description" yaml:"description"`
	CreatedAt   time.Time           `json:"created_at" yaml:"created_at"`
	UpdatedAt   time.Time           `json:"updated_at" yaml:"updated_at"`
	Status      string              `json:"status" yaml:"status"`
	StatusCode  api.StatusCode      `json:"status_code" yaml:"status_code" shadow:"status_code"`
	Resources   map[string][]string `json:"resources" yaml:"resources"`
	Metadata    map[string]any      `json:"metadata" yaml:"metadata"`
	MayCancel   bool                `json:"may_cancel" yaml:"may_cancel"`
	Err         string              `json:"err" yaml:"err"`
	Location    string              `json:"location" yaml:"location"`
}

func (op *Operation) ToCertificateAddToken() (*CertificateAddToken, error) {
	req, ok := op.Metadata["request"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("Operation request is type %T not map[string]any", op.Metadata["request"])
	}

	clientName, ok := req["name"].(string)
	if !ok {
		return nil, fmt.Errorf("Failed to get client name")
	}

	secret, ok := op.Metadata["secret"].(string)
	if !ok {
		return nil, fmt.Errorf("Operation secret is type %T not string", op.Metadata["secret"])
	}

	fingerprint, ok := op.Metadata["fingerprint"].(string)
	if !ok {
		return nil, fmt.Errorf("Operation fingerprint is type %T not string", op.Metadata["fingerprint"])
	}

	addresses, ok := op.Metadata["addresses"].([]any)
	if !ok {
		return nil, fmt.Errorf("Operation addresses is type %T not []any", op.Metadata["addresses"])
	}

	joinToken := CertificateAddToken{
		ClientName:  clientName,
		Secret:      secret,
		Fingerprint: fingerprint,
		Addresses:   make([]string, 0, len(addresses)),
	}

	expiresAtStr, ok := op.Metadata["expiresAt"].(string)
	if ok {
		expiresAt, err := time.Parse(time.RFC3339Nano, expiresAtStr)
		if err != nil {
			return nil, err
		}

		joinToken.ExpiresAt = expiresAt
	}

	for i, address := range addresses {
		addressString, ok := address.(string)
		if !ok {
			return nil, fmt.Errorf("Operation address index %d is type %T not string", i, address)
		}

		joinToken.Addresses = append(joinToken.Addresses, addressString)
	}

	return &joinToken, nil
}

func (op *Operation) ToClusterJoinToken() (*ClusterMemberJoinToken, error) {
	serverName, ok := op.Metadata["serverName"].(string)
	if !ok {
		return nil, fmt.Errorf("Operation serverName is type %T not string", op.Metadata["serverName"])
	}

	secret, ok := op.Metadata["secret"].(string)
	if !ok {
		return nil, fmt.Errorf("Operation secret is type %T not string", op.Metadata["secret"])
	}

	fingerprint, ok := op.Metadata["fingerprint"].(string)
	if !ok {
		return nil, fmt.Errorf("Operation fingerprint is type %T not string", op.Metadata["fingerprint"])
	}

	addresses, ok := op.Metadata["addresses"].([]any)
	if !ok {
		return nil, fmt.Errorf("Operation addresses is type %T not []any", op.Metadata["addresses"])
	}

	expiresAtStr, ok := op.Metadata["expiresAt"].(string)
	if !ok {
		return nil, fmt.Errorf("Operation expiresAt is type %T not string", op.Metadata["expiresAt"])
	}

	expiresAt, err := time.Parse(time.RFC3339Nano, expiresAtStr)
	if err != nil {
		return nil, err
	}

	joinToken := ClusterMemberJoinToken{
		ServerName:  serverName,
		Secret:      secret,
		Fingerprint: fingerprint,
		Addresses:   make([]string, 0, len(addresses)),
		ExpiresAt:   expiresAt,
	}

	for i, address := range addresses {
		addressString, ok := address.(string)
		if !ok {
			return nil, fmt.Errorf("Operation address index %d is type %T not string", i, address)
		}

		joinToken.Addresses = append(joinToken.Addresses, addressString)
	}

	return &joinToken, nil
}
