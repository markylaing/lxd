package main

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/canonical/lxd/shared"
)

var skipFiles = []string{
	"error.go",
	"url.go",
	"url_test.go",
	"status_code.go",
}

var fieldReplacements = map[string]struct {
	Import string
	Type   string
}{
	"pem_encoded_x509_certificate":    {Import: "github.com/canonical/lxd/lxd/shadowapi/types", Type: "types.X509CertificatePEM"},
	"base64_encoded_x509_certificate": {Import: "github.com/canonical/lxd/lxd/shadowapi/types", Type: "types.X509CertificateBase64"},
	"auth_entitlements":               {Import: "github.com/canonical/lxd/lxd/auth", Type: "[]auth.Entitlement"},
	"instance_type":                   {Import: "github.com/canonical/lxd/lxd/instance/instancetype", Type: "instancetype.Type"},
	"status_code":                     {Import: "github.com/canonical/lxd/shared/api", Type: "api.StatusCode"},
	"response_type":                   {Import: "github.com/canonical/lxd/shared/api", Type: "api.ResponseType"},
	"certificate_type":                {Import: "github.com/canonical/lxd/lxd/certificate", Type: "certificate.Type"},
}

var omitFuncs = map[string]string{
	"*WithEntitlements": "ReportEntitlements",
	"*":                 "URL",
}

var constReplacements = map[string]struct {
	Import string
	Value  string
}{
	"EventTypeLogging":   {Import: "github.com/canonical/lxd/shared/api", Value: "api.EventTypeLogging"},
	"EventTypeOperation": {Import: "github.com/canonical/lxd/shared/api", Value: "api.EventTypeOperation"},
	"EventTypeOVN":       {Import: "github.com/canonical/lxd/shared/api", Value: "api.EventTypeOVN"},
	"EventTypeLifecycle": {Import: "github.com/canonical/lxd/shared/api", Value: "api.EventTypeLifecycle"},
	"Stopped":            {Import: "github.com/canonical/lxd/shared/api", Value: "api.Stopped"},
	" Error":             {Import: "github.com/canonical/lxd/shared/api", Value: " api.Error"},
}

type file struct {
	pkg     string
	imports []string
	lines   []line
}

func exit(err error) {
	_, _ = os.Stderr.Write([]byte(err.Error()))
	os.Exit(1)
}

func (f *file) write(w io.StringWriter) {
	writeLine(w, "// Code generated by shadowapi/generate - DO NOT EDIT!", 0, 1)
	writeLine(w, "package "+f.pkg, 0, 1)
	if len(f.imports) > 0 {
		writeLine(w, "import (", 0, 0)
		for _, i := range f.imports {
			writeLine(w, i, 1, 0)
		}

		writeLine(w, ")", 0, 1)
	}

	for _, l := range f.lines {
		writeLine(w, l.content, l.indents, l.additionalNewLines)
	}
}

func (f *file) appendLine(l string, indents uint8, additionalNewLines uint8) {
	f.lines = append(f.lines, line{
		content:            l,
		indents:            indents,
		additionalNewLines: additionalNewLines,
	})
}

type line struct {
	content            string
	indents            uint8
	additionalNewLines uint8
}

func write(writer io.StringWriter, s string) {
	_, err := writer.WriteString(s)
	if err != nil {
		exit(err)
	}
}

func writeLine(writer io.StringWriter, line string, indents uint8, additionalNewlines uint8) {
	var i uint8
	for i = 0; i < indents; i++ {
		write(writer, "\t")
	}

	write(writer, line+"\n")
	for i = 0; i < additionalNewlines; i++ {
		write(writer, "\n")
	}
}

func main() {
	args := os.Args
	if len(args) != 3 {
		exit(errors.New("input and output directories required"))
	}

	outputDir := args[2]
	err := os.MkdirAll(outputDir, 0750)
	if err != nil {
		exit(err)
	}

	inputDir := args[1]
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, inputDir, nil, parser.SkipObjectResolution)
	if err != nil {
		exit(err)
	}

	for pkgName, pkg := range pkgs {
		for pkgFilepath, pkgFile := range pkg.Files {
			pkgFileName := filepath.Base(pkgFilepath)
			if shared.ValueInSlice(pkgFileName, skipFiles) {
				continue
			}

			absPath, err := filepath.Abs(outputDir)
			if err != nil {
				exit(err)
			}

			f := &file{
				pkg: filepath.Base(absPath),
			}

			for _, decl := range pkgFile.Decls {
				funcDecl, ok := decl.(*ast.FuncDecl)
				if ok {
					doFuncDecl(f, funcDecl, fset)
					continue
				}

				genDecl, ok := decl.(*ast.GenDecl)
				if ok {
					doGenDecl(f, genDecl, pkgName, fset)
					continue
				}

				fmt.Println("missed decl", decl)
			}

			outfile, err := os.Create(filepath.Join(outputDir, pkgFileName))
			if err != nil {
				exit(err)
			}

			defer outfile.Close()
			f.write(outfile)
		}
	}
}

func doFuncDecl(f *file, decl *ast.FuncDecl, fset *token.FileSet) {
	name := decl.Name.Name
	omittedFuncName, ok := omitFuncs["*"]
	if ok && name == omittedFuncName {
		return
	}

	var rcvType string
	if decl.Recv != nil && len(decl.Recv.List) == 1 && decl.Recv.List[0].Type != nil {
		rcvType = types.ExprString(decl.Recv.List[0].Type)
	}

	omittedFuncName, ok = omitFuncs[rcvType]
	if ok && name == omittedFuncName {
		return
	}

	start := fset.Position(decl.Pos())
	end := fset.Position(decl.End())
	b, err := os.ReadFile(start.Filename)
	if err != nil {
		exit(err)
	}

	funcDeclText := string(b[start.Offset:end.Offset])
	for n, r := range constReplacements {
		replacedFuncDeclText := strings.Replace(funcDeclText, n, r.Value, -1)
		if replacedFuncDeclText != funcDeclText {
			funcDeclText = replacedFuncDeclText
			i := `"` + r.Import + `"`
			if !shared.ValueInSlice(i, f.imports) {
				f.imports = append(f.imports, i)
			}
		}
	}

	f.appendLine(funcDeclText, 0, 1)
}

func doImportSpec(f *file, spec *ast.ImportSpec) {
	if spec == nil || spec.Path == nil {
		return
	}

	f.imports = append(f.imports, spec.Path.Value)
}

func doTypeSpec(f *file, sourcePkgName string, spec *ast.TypeSpec) {
	structType, ok := spec.Type.(*ast.StructType)
	if !ok {
		return
	}

	doStructSpec(f, sourcePkgName, spec, structType)
}

func doStructSpec(f *file, sourcePkgName string, typeSpec *ast.TypeSpec, structType *ast.StructType) {
	f.appendLine("// "+typeSpec.Name.Name+" is generated from "+sourcePkgName+"."+typeSpec.Name.Name+" - DO NOT EDIT!", 0, 0)
	f.appendLine("type "+typeSpec.Name.Name+" struct {", 0, 0)
	for _, field := range structType.Fields.List {
		if field == nil || field.Type == nil {
			continue
		}

		if field.Names == nil {
			line := types.ExprString(field.Type)
			if field.Tag != nil {
				line += " " + field.Tag.Value
			}

			f.appendLine(line, 1, 0)
			continue
		}

		if len(field.Names) != 1 || field.Names[0] == nil {
			exit(fmt.Errorf("encountered strange field definition for type %q", typeSpec.Name.Name))
		}

		fieldLine := []string{field.Names[0].Name}
		typeName := types.ExprString(field.Type)
		if field.Tag == nil {
			fieldLine = append(fieldLine, typeName)
		} else {
			shadowKey, ok := reflect.StructTag(field.Tag.Value).Lookup("shadow")
			if ok {
				r, ok := fieldReplacements[shadowKey]
				if !ok {
					exit(fmt.Errorf("Invalid shadow type key %q", shadowKey))
				}

				typeName = r.Type
				shadowImport := `"` + r.Import + `"`
				if !shared.ValueInSlice(shadowImport, f.imports) {
					f.imports = append(f.imports, shadowImport)
				}

			}

			fieldLine = append(fieldLine, typeName, field.Tag.Value)
		}

		f.appendLine(strings.Join(fieldLine, " "), 1, 0)
	}

	f.appendLine("}", 0, 1)
}

var doneGenDecls = map[string]struct{}{}

func doGenDecl(f *file, decl *ast.GenDecl, sourcePkgName string, fset *token.FileSet) {
	for _, genSpec := range decl.Specs {
		switch spec := genSpec.(type) {
		case *ast.ImportSpec:
			doImportSpec(f, spec)
			continue
		case *ast.TypeSpec:
			doTypeSpec(f, sourcePkgName, spec)
			continue
		default:
			//start := fset.Position(decl.Pos())
			//end := fset.Position(decl.End())
			//b, err := os.ReadFile(start.Filename)
			//if err != nil {
			//	exit(err)
			//}
			//
			//declStr := string(b[start.Offset:end.Offset])
			//_, ok := doneGenDecls[declStr]
			//if ok {
			//	continue
			//}
			//
			//f.appendLine(declStr, 0, 1)
			//doneGenDecls[declStr] = struct{}{}
		}
	}
}
